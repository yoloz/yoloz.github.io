<!DOCTYPE html>
<html>
<head>
	<title>Yoloz</title>
	<meta charset="utf-8">

	<!-- 引入配置文件 -->
	
<link rel="stylesheet" href="/css/main.css">


	<!-- 字体图片库 -->
	
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


	<!-- 代码高亮库 -->
	
<link rel="stylesheet" href="/lib/highlight/styles/atom-one-dark.css">

	
<meta name="generator" content="Hexo 4.2.0"></head>
<body>

	<div id="main">
		<!-- 引入侧边栏 -->
		<aside>
			<!-- 搜索栏 -->
<div id="search">
	<input class="search-input" type="text" placeholder="filter by name"/>
	<i id="search-icon" class="fa fa-bars" title="切换目录与索引"></i>
</div>

<!-- 侧边目录栏 -->
<div id="tree">
	

	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				database
			</a>
			
	<ul>
		<li class="file">
			<a href="/2020/02/20/database/mysql使用/">
				<i class="fa fa-file"></i>
				mysql使用
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/20/database/概述DQL,DML,DDL,DCL/">
				<i class="fa fa-file"></i>
				概述DQL,DML,DDL,DCL
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				hadoop
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/09/18/hadoop/hadoop-2.7.3单机搭建/">
				<i class="fa fa-file"></i>
				hadoop-2.7.3单机搭建
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/03/hadoop/hbase架构了解/">
				<i class="fa fa-file"></i>
				hbase架构了解
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/hadoop/hive-2.1.0单机搭建/">
				<i class="fa fa-file"></i>
				hive-2.1.0单机搭建
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				java
			</a>
			
	<ul>
		<li class="file">
			<a href="/2020/04/01/java/CompletableFuture详解/">
				<i class="fa fa-file"></i>
				CompletableFuture详解
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/03/10/java/JVM调式工具/">
				<i class="fa fa-file"></i>
				JVM调式工具
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/28/java/ReentrantLock/">
				<i class="fa fa-file"></i>
				ReentrantLock
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/07/30/java/date与localDateTime/">
				<i class="fa fa-file"></i>
				date与localDateTime
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/28/java/jar的使用/">
				<i class="fa fa-file"></i>
				jar的使用
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/03/10/java/javaThreadDump日志分析/">
				<i class="fa fa-file"></i>
				javaThreadDump日志分析
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/14/java/java进程占用virt虚拟内存高的问题研究/">
				<i class="fa fa-file"></i>
				java进程占用virt虚拟内存高的问题研究
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/02/15/java/jvm启动参数/">
				<i class="fa fa-file"></i>
				jvm启动参数
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/07/30/java/读取InputStream生成String/">
				<i class="fa fa-file"></i>
				读取InputStream生成String
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				kafka
			</a>
			
	<ul>
		<li class="file active">
			<a href="/2018/12/11/kafka/consumerApi/">
				<i class="fa fa-file"></i>
				consumerApi
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/01/26/kafka/producer/">
				<i class="fa fa-file"></i>
				producer
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/01/23/kafka/sasl-plaintext-acl/">
				<i class="fa fa-file"></i>
				sasl-plaintext-acl
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				linux
			</a>
			
	<ul>
		<li class="file">
			<a href="/2020/02/29/linux/DNS/">
				<i class="fa fa-file"></i>
				DNS
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/03/19/linux/Locale/">
				<i class="fa fa-file"></i>
				Locale
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/07/24/linux/alternatives/">
				<i class="fa fa-file"></i>
				alternatives
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/26/linux/du,df/">
				<i class="fa fa-file"></i>
				du,df
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/03/11/linux/killall,kill,pkill/">
				<i class="fa fa-file"></i>
				killall,kill,pkill
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/03/10/linux/ncat(nc)/">
				<i class="fa fa-file"></i>
				ncat(nc)
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/30/linux/ps/">
				<i class="fa fa-file"></i>
				ps
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/linux/shell中sh, exec, source, fork的区别/">
				<i class="fa fa-file"></i>
				shell中sh, exec, source, fork的区别
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/26/linux/ssh/">
				<i class="fa fa-file"></i>
				ssh
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/11/13/linux/tcp连接数/">
				<i class="fa fa-file"></i>
				tcp连接数
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/11/13/linux/ulimit/">
				<i class="fa fa-file"></i>
				ulimit
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/30/linux/vim/">
				<i class="fa fa-file"></i>
				vim
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/linux/which,whereis,locate,find/">
				<i class="fa fa-file"></i>
				which,whereis,locate,find
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/29/linux/服务自启动/">
				<i class="fa fa-file"></i>
				服务自启动
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/linux/用户及组/">
				<i class="fa fa-file"></i>
				用户及组
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/04/linux/编写shell/">
				<i class="fa fa-file"></i>
				编写shell
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/29/linux/静态ip地址/">
				<i class="fa fa-file"></i>
				静态ip地址
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				lucene
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/02/18/lucene/Lucene的Index文档模型/">
				<i class="fa fa-file"></i>
				Lucene的Index文档模型
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				network
			</a>
			
	<ul>
		<li class="file">
			<a href="/2020/02/23/network/TCPIP常見封包/">
				<i class="fa fa-file"></i>
				TCPIP常見封包
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/23/network/cksum(checksum)incorrect/">
				<i class="fa fa-file"></i>
				cksum(checksum)incorrect
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/03/10/network/tcp_timestamps/">
				<i class="fa fa-file"></i>
				tcp_timestamps
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/23/network/tcpdump/">
				<i class="fa fa-file"></i>
				tcpdump
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				other
			</a>
			
	<ul>
		<li class="file">
			<a href="/2018/12/10/other/git/">
				<i class="fa fa-file"></i>
				git
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/27/other/hexo搭建博客/">
				<i class="fa fa-file"></i>
				hexo搭建博客
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/27/other/start-hexo/">
				<i class="fa fa-file"></i>
				start-hexo
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/05/other/svn/">
				<i class="fa fa-file"></i>
				svn
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/02/19/other/yaml格式/">
				<i class="fa fa-file"></i>
				yaml格式
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/02/15/other/五种开源协议(GPL,LGPL,BSD,MIT,Apache)/">
				<i class="fa fa-file"></i>
				五种开源协议(GPL,LGPL,BSD,MIT,Apache)
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				security
			</a>
			
	<ul>
		<li class="file">
			<a href="/2020/04/17/security/keytool命令详解/">
				<i class="fa fa-file"></i>
				keytool命令详解
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				web
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/02/20/web/javaScript遍历对象、数组/">
				<i class="fa fa-file"></i>
				javaScript遍历对象、数组
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/29/web/npm,nvm,nrm,npx,cnpm/">
				<i class="fa fa-file"></i>
				npm,nvm,nrm,npx,cnpm
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/29/web/react-loadable代码分割/">
				<i class="fa fa-file"></i>
				react-loadable代码分割
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/02/20/web/react组件之间通信/">
				<i class="fa fa-file"></i>
				react组件之间通信
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
</div>


<!-- 展示文章内部标题 -->
<div id="toc" style="display: none;">
</div>
		</aside>

		<!-- 引入导航 -->
		<nav>
			<div class="container-fluid">
    <ul id="menu">
        
        
        <li class="menu-item">
            <a href="/" class="menu-item-link">主页</a>
        </li>
        
        <li class="menu-item">
            <a href="/about" class="menu-item-link">关于</a>
        </li>
        

        
        
        <li class="menu-item">
            <a href="https://github.com/yoloz" class="menu-item-link" target="_blank">github</a>
        </li>
        
    </ul>
</div>
		</nav>

		<!-- 引入正文 -->
		<div id="content">
			<div style="background: #eee">
	<span id="post-author">yoloz</span>
	<span id="post-date">2018-12-11 16:03:11</span>
</div>

<div id="article">
	<p>如下是kafka消费者java api的订阅(subscribe)流程(v0.10)</p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p>实现类org.apache.kafka.clients.consumer. KafkaConsumer.java</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">private</span> <span class="title">KafkaConsumer</span><span class="params">(ConsumerConfig config,</span></span>
<span class="function"><span class="params">                      Deserializer&lt;K&gt; keyDeserializer,</span></span>
<span class="function"><span class="params">                      Deserializer&lt;V&gt; valueDeserializer)</span> </span>&#123;
    <span class="keyword">try</span> &#123;......&#125; <span class="keyword">catch</span> (Throwable t) &#123;
        <span class="comment">// call close methods if internal objects are already constructed</span>
        <span class="comment">// this is to prevent resource leak. see KAFKA-2121</span>
        close(<span class="number">0</span>, <span class="keyword">true</span>);
        <span class="comment">// now propagate the exception</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Failed to construct kafka consumer"</span>, t);
    &#125;
&#125;</code></pre>

<p>try块中，一些相关参数的处理(略)，其次一些对象的初始化。</p>
<pre><code class="highlight java">ClusterResourceListeners clusterResourceListeners = configureClusterResourceListeners(keyDeserializer, valueDeserializer, reporters, interceptorList);
<span class="keyword">this</span>.metadata = <span class="keyword">new</span> Metadata(retryBackoffMs, config.getLong(ConsumerConfig.METADATA_MAX_AGE_CONFIG), <span class="keyword">false</span>, clusterResourceListeners);
List&lt;InetSocketAddress&gt; addresses = ClientUtils.parseAndValidateAddresses(config.getList(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG));
<span class="keyword">this</span>.metadata.update(Cluster.bootstrap(addresses), Collections.&lt;String&gt;emptySet(), <span class="number">0</span>);</code></pre>

<blockquote>
<p>ClusterResourceListener  </p>
</blockquote>
<p>A callback interface that users can implement when they wish to get notified about changes in the Cluster metadata. Users who need access to cluster metadata in interceptors, metric reporters, serializers and deserializers can implement this interface.<br>回调接口，获取集群相关信息的变动。</p>
<blockquote>
<p>Metadata  </p>
</blockquote>
<p>A class encapsulating some of the logic around metadata.<br> This class is shared by the client thread (for partitioning) and the background sender thread.<br> Metadata is maintained for only a subset of topics, which can be added to over time. When we request metadata for a topic we don’t have any metadata for it will trigger a metadata update.<br> If topic expiry is enabled for the metadata, any topic that has not been used within the expiry interval is removed from the metadata refresh set after an update. Consumers disable topic expiry since they explicitly manage topics while producers rely on topic expiry to limit the refresh set.<br>元数据类。<br>客户端线程(for partitioning)和后台发送线程共享元数据。<br>元数据仅维护主题的一小部分，随时间增加，当向主题请求元数据时，如果没有元数据，则触发元数据更新。<br> 如果元数据启用了到期功能，在更新操作中将从元数据集中删除过期的主题。消费者禁用主题到期，因为它们明确地管理主题，而生产者依靠主题到期来限制刷新集大小。</p>
<pre><code class="highlight java">ChannelBuilder channelBuilder = ClientUtils.createChannelBuilder(config);
NetworkClient netClient = <span class="keyword">new</span> NetworkClient(
        <span class="keyword">new</span> Selector(config.getLong(ConsumerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG), metrics, time, metricGrpPrefix, channelBuilder),
        <span class="keyword">this</span>.metadata,
       ................);
<span class="keyword">this</span>.client = <span class="keyword">new</span> ConsumerNetworkClient(netClient, metadata, time, retryBackoffMs,
        config.getInt(ConsumerConfig.REQUEST_TIMEOUT_MS_CONFIG));</code></pre>

<blockquote>
<p>ChannelBuilder  </p>
</blockquote>
<p>A ChannelBuilder interface to build Channel based on configs.</p>
<blockquote>
<p>NetworkClient  </p>
</blockquote>
<p>A network client for asynchronous request/response network i/o. This is an internal class used to implement the user-facing producer and consumer clients.<br>This class is not thread-safe!<br>面向生产者消费者客户端的网络内部类，异步网络IO，非线程安全。</p>
<blockquote>
<p>ConsumerNetworkClient  </p>
</blockquote>
<p>Higher level consumer access to the network layer with basic support for request futures. This class is thread-safe, but provides no synchronization for response callbacks. This guarantees that no locks are held when they are invoked.<br>支持基本reuqest future的网络层，线程安全，但不提供响应回调的同步。可以确保在调用时不会保留锁。</p>
<pre><code class="highlight java">OffsetResetStrategy offsetResetStrategy = OffsetResetStrategy.valueOf(config.getString(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG).toUpperCase(Locale.ROOT));
<span class="keyword">this</span>.subscriptions = <span class="keyword">new</span> SubscriptionState(offsetResetStrategy);
List&lt;PartitionAssignor&gt; assignors = config.getConfiguredInstances(
        ConsumerConfig.PARTITION_ASSIGNMENT_STRATEGY_CONFIG,
        PartitionAssignor<span class="class">.<span class="keyword">class</span>)</span>;
<span class="keyword">this</span>.coordinator = <span class="keyword">new</span> ConsumerCoordinator(..............);
<span class="keyword">this</span>.fetcher = <span class="keyword">new</span> Fetcher&lt;&gt;(............................);</code></pre>

<blockquote>
<p>OffsetResetStrategy  </p>
</blockquote>
<p>枚举类LATEST, EARLIEST, NONE</p>
<blockquote>
<p>PartitionAssignor  </p>
</blockquote>
<p>this interface is used to define custom partition assignment for use in KafkaConsumer. Members of the consumer group subscribe to the topics they are interested in and forward their subscriptions to a Kafka broker serving as the group coordinator. The coordinator selects one member to perform the group assignment and propagates the subscriptions of all members to it. Then assign(Cluster, Map)} is called to perform the assignment and the results are forwarded back to each respective members<br>In some cases, it is useful to forward additional metadata to the assignor in order to make assignment decisions. For this, you can override {@link #subscription(Set)} and provide custom userData in the returned Subscription. For example, to have a rack-aware assignor, an implementation can use this user data to forward the rackId belonging to each member.<br>消费者的分区分配接口</p>
<blockquote>
<p>ConsumerCoordinator  </p>
</blockquote>
<p>This class manages the coordination process with the consumer coordinator.<br>消费者协调员管理</p>
<blockquote>
<p>Fetcher  </p>
</blockquote>
<p>This class manage the fetching process with the brokers.<br>管理从broker抓取数据</p>
<h2 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h2><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics)</span> </span>&#123;
    subscribe(topics, <span class="keyword">new</span> NoOpConsumerRebalanceListener());
&#125;</code></pre>

<p>Subscribe to the given list of topics to get dynamically assigned partitions. Topic subscriptions are not incremental. This list will replace the current assignment (if there is one). It is not possible to combine topic subscription with group management with manual partition assignment through assign(Collection).<br>订阅给定主题列表，分区动态分配。与自定义分配(assign())不可同时使用。</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;
.......................
     <span class="keyword">this</span>.subscriptions.subscribe(<span class="keyword">new</span> HashSet&lt;&gt;(topics), listener);
     metadata.setTopics(subscriptions.groupSubscription());
.......................
&#125;</code></pre>

<p>As part of group management, the consumer will keep track of the list of consumers that belong to a particular group and will trigger a rebalance operation if one of the following events trigger<br>新消费者的加入，组管理中消费者会可能属于已经存在的组，或者新组。如果发生以下事件将触发重新平衡操作：</p>
<ul>
<li>Number of partitions change for any of the subscribed list of topics. 已订阅主题列表的分区改动</li>
<li>Topic is created or deleted. 主题创建或删除</li>
<li>An existing member of the consumer group dies. 组中有成员离线(死亡)</li>
<li>A new member is added to an existing consumer group via the join API. 组中有新成员加入</li>
</ul>
<p>当触发任何这些事件时，将首先调用提供的侦听器来指示消费者的作业已被撤销，然后再次接收到新的作业。</p>
<h2 id="consumer-poll"><a href="#consumer-poll" class="headerlink" title="consumer poll"></a>consumer poll</h2><p>实现类org.apache.kafka.clients.consumer. KafkaConsumer.java</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;
    acquire();
    <span class="keyword">try</span> &#123;
        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Timeout must not be negative"</span>);

        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment())
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Consumer is not subscribed to any topics or assigned any partitions"</span>);

        <span class="comment">// poll for new data until the timeout expires</span>
        <span class="keyword">long</span> start = time.milliseconds();
        <span class="keyword">long</span> remaining = timeout;
        <span class="keyword">do</span> &#123;
         Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records =pollOnce(remaining);
            <span class="keyword">if</span> (!records.isEmpty()) &#123;
                  <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> ||
        client.hasPendingRequests())&#123;client.pollNoWakeup();&#125;
.......&#125;
            <span class="keyword">long</span> elapsed = time.milliseconds() - start;
            remaining = timeout - elapsed;
        &#125; <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>);
        <span class="keyword">return</span> ConsumerRecords.empty();
&#125; <span class="keyword">finally</span> &#123;
        release();
    &#125;
&#125;</code></pre>

<blockquote>
<p>acquire()  </p>
</blockquote>
<p>判断consumer是否多线程访问，consumer非线程安全，如果多线程使用会报异常ConcurrentModificationException</p>
<pre><code class="highlight java"><span class="keyword">if</span>(!records.isEmpty())&#123;
    <span class="keyword">if</span>(fetcher.sendFetches()&gt;<span class="number">0</span>||client.hasPendingRequests())&#123;
        client.pollNoWakeup();
    &#125;
    ........
&#125;</code></pre>

<p>before returning the fetched records, we can send off the next round of fetches and avoid block waiting for their responses to enable pipelining while the user is handling the fetched records.<br>在返回抓取的数据时，发送下一轮提取请求。即，用户在接收到数据的时候，下一次提取数据的请求已经发出去了。</p>
<blockquote>
<p>pollOnce  </p>
</blockquote>
<p>实现类org.apache.kafka.clients.consumer. KafkaConsumer.java<br>Do one round of polling. In addition to checking for new data, this does any needed offset commits (if auto-commit is enabled), and offset resets (if an offset reset policy is defined).<br>一次poll。除了检查新数据，还会涉及offset提交以及offset reset。</p>
<pre><code class="highlight java"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollOnce(<span class="keyword">long</span> timeout) &#123;
    client.maybeTriggerWakeup();
    coordinator.poll(time.milliseconds());
    <span class="comment">// fetch positions if we have partitions we're subscribed to that we</span>
    <span class="comment">// don't know the offset for</span>
    <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions())
        updateFetchPositions(<span class="keyword">this</span>.subscriptions.missingFetchPositions());
    <span class="comment">// if data is available already, return it immediately</span>
   Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();
    <span class="keyword">if</span> (!records.isEmpty())
        <span class="keyword">return</span> records;
    <span class="comment">// send any new fetches (won't resend pending fetches)</span>
    fetcher.sendFetches();
    <span class="keyword">long</span> now = time.milliseconds();
    <span class="keyword">long</span> pollTimeout = Math.min(coordinator.timeToNextPoll(now), timeout);
    client.poll(pollTimeout, now, <span class="keyword">new</span> PollCondition() &#123;
        <span class="meta">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldBlock</span><span class="params">()</span> </span>&#123;
       <span class="comment">// since a fetch might be completed by the background thread, we need this poll condition to ensure that we do not block unnecessarily in poll()</span>
            <span class="keyword">return</span> !fetcher.hasCompletedFetches();
        &#125;
    &#125;);
    <span class="comment">// after the long poll, we should check whether the group needs to rebalance prior to returning data so that the group can stabilize faster</span>
    <span class="keyword">if</span> (coordinator.needRejoin())
        <span class="keyword">return</span> Collections.emptyMap();
    <span class="keyword">return</span> fetcher.fetchedRecords();
&#125;</code></pre>

<blockquote>
<p>client.maybeTriggerWakeup()  </p>
</blockquote>
<p>响应用户的wakeup，抛出WakeupException，如多线程使用中以此来停止consumer。  </p>
<blockquote>
<p>coordinator.poll  </p>
</blockquote>
<p>实现类org.apache.kafka.clients.consumer.internals. ConsumerCoordinator.java<br>Poll for coordinator events. This ensures that the coordinator is known and that the consumer has joined the group (if it is using group management). This also handles periodic offset commits if they are enabled.<br>coordinator的poll事件，如下：</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;
    invokeCompletedOffsetCommitCallbacks();
    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned() &amp;&amp; coordinatorUnknown()) &#123;
        ensureCoordinatorReady();
        now = time.milliseconds();
    &#125;
    <span class="keyword">if</span> (needRejoin()) &#123;
<span class="comment">// due to a race condition between the initial metadata fetch and the initial rebalance, we need to ensure that the metadata is fresh before joining initially. This ensures that we have matched the pattern against the cluster's topics at least once before joining.</span>
        <span class="keyword">if</span> (subscriptions.hasPatternSubscription())
            client.ensureFreshMetadata();
            ensureActiveGroup();
            now = time.milliseconds();
    &#125;
    pollHeartbeat(now);
    maybeAutoCommitOffsetsAsync(now);
&#125;</code></pre>

<blockquote>
<p>invokeCompletedOffsetCommitCallbacks  </p>
</blockquote>
<p>ConcurrentLinkedQueue<OffsetCommitCompletion>：<br>this collection must be thread-safe because it is modified from the response handler of offset commit requests, which may be invoked from the heartbeat thread.<br>线程安全的集合(队列)，commit offset请求响应逻辑中更改或者心跳线程中调用。offsetcommit的callback返回中处理一些逻辑，如果已消费的offset记录server没有表示，得阻塞处理(invoke)。</p>
<pre><code class="highlight java"><span class="keyword">if</span> (subscriptions.partitionsAutoAssigned() &amp;&amp; coordinatorUnknown()) &#123;
        ensureCoordinatorReady();
        now = time.milliseconds();
    &#125;</code></pre>

<blockquote>
<p>保证coordinator就绪(是好的)，否则阻塞(ensureCoordinatorReady()阻塞处理逻辑)  </p>
</blockquote>
<p>Block until the coordinator for this group is known and is ready to receive requests.</p>
<blockquote>
<p>needRejoin()  </p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">if</span> (!subscriptions.partitionsAutoAssigned())
    <span class="keyword">return</span> <span class="keyword">false</span>;
<span class="comment">// we need to rejoin if we performed the assignment and metadata has changed</span>
<span class="keyword">if</span> (assignmentSnapshot != <span class="keyword">null</span> &amp;&amp; !assignmentSnapshot.equals(metadataSnapshot))
    <span class="keyword">return</span> <span class="keyword">true</span>;
<span class="comment">// we need to join if our subscription has changed since the last join</span>
<span class="keyword">if</span> (joinedSubscription != <span class="keyword">null</span> &amp;&amp; !joinedSubscription.equals(subscriptions.subscription()))
    <span class="keyword">return</span> <span class="keyword">true</span>;
<span class="keyword">return</span> <span class="keyword">super</span>.needRejoin();</code></pre>

<p>如果调用subscribe接口消费，则partitionsAutoAssigned为true。<br>如果使用模式匹配的话，则要ensureFreshMetadata：<br>Ensure our metadata is fresh (if an update is expected, this will block until it has completed).</p>
<blockquote>
<p>ensureActiveGroup()  </p>
</blockquote>
<p>Ensure that the group is active (i.e. joined and synced)</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureActiveGroup</span><span class="params">()</span> </span>&#123;
<span class="comment">// always ensure that the coordinator is ready because we may have been disconnected when sending heartbeats and does not necessarily require us to rejoin the group.</span>
    ensureCoordinatorReady();
    startHeartbeatThreadIfNeeded();
    joinGroupIfNeeded();
&#125;</code></pre>

<blockquote>
<p>ensureCoordinatorReady()  </p>
</blockquote>
<p>ensureCoordinatorReady(): Block until the coordinator for this group is known and is ready to receive requests.</p>
<blockquote>
<p>pollHeartbeat(now)  </p>
</blockquote>
<p>Check the status of the heartbeat thread (if it is active) and indicate the liveness of the client. This must be called periodically after joining with ensureActiveGroup() to ensure that the member stays in the group. If an interval of time longer than the provided rebalance timeout expires without calling this method, then the client will proactively leave the group.<br>通过心跳判断client是否存活，周期性的发送心跳包，如果超时则client将被移出所在组。</p>
<blockquote>
<p>maybeAutoCommitOffsetsAsync(now)  </p>
</blockquote>
<pre><code class="highlight java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeAutoCommitOffsetsAsync</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;
    <span class="keyword">if</span> (autoCommitEnabled) &#123;
        <span class="keyword">if</span> (coordinatorUnknown()) &#123;
            <span class="keyword">this</span>.nextAutoCommitDeadline = now + retryBackoffMs;
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now &gt;= nextAutoCommitDeadline) &#123;
            <span class="keyword">this</span>.nextAutoCommitDeadline = now + autoCommitIntervalMs;
            doAutoCommitOffsetsAsync();
        &#125;
    &#125;
&#125;

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAutoCommitOffsetsAsync</span><span class="params">()</span> </span>&#123;
Map&lt;TopicPartition, OffsetAndMetadata&gt; allConsumedOffsets = subscriptions.allConsumed();
    commitOffsetsAsync(allConsumedOffsets, <span class="keyword">new</span> OffsetCommitCallback() &#123;......&#125;);
&#125;

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitOffsetsAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, <span class="keyword">final</span> OffsetCommitCallback callback)</span> </span>&#123;
invokeCompletedOffsetCommitCallbacks();
<span class="keyword">if</span> (!coordinatorUnknown()) &#123;
   doCommitOffsetsAsync(offsets, callback);
    &#125; <span class="keyword">else</span> &#123;.......&#125;

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommitOffsetsAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, <span class="keyword">final</span> OffsetCommitCallback callback)</span> </span>&#123;
    <span class="keyword">this</span>.subscriptions.needRefreshCommits();
    RequestFuture&lt;Void&gt; future = sendOffsetCommitRequest(offsets);
...................
    future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;Void&gt;() &#123;
..............
completedOffsetCommits.add(<span class="keyword">new</span> OffsetCommitCompletion(cb, offsets, <span class="keyword">null</span>));
..............
&#125;</code></pre>

<blockquote>
<p>sendOffsetCommitRequest(offsets)  </p>
</blockquote>
<p>Commit offsets for the specified list of topics and partitions. This is a non-blocking call which returns a request future that can be polled in the case of a synchronous commit or ignored in the asynchronous case.<br>提交具体的topic和partition的offsets，非阻塞，返回future.</p>
<blockquote>
<p>subscriptions.allConsumed()  </p>
</blockquote>
<p>获取提交的offset，如下：</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; <span class="title">allConsumed</span><span class="params">()</span> </span>&#123;
......................  
allConsumed.put(state.topicPartition(),newOffsetAndMetadata(state.value().position).............&#125;
<span class="comment">//state.value().position即下面的position，最后消费的位置，由下文的fetchPositions更新</span>

<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartitionState</span> </span>&#123;
    <span class="keyword">private</span> Long position; <span class="comment">// last consumed position</span>
    <span class="keyword">private</span> Long highWatermark; <span class="comment">// the high watermark from last fetch</span>
    <span class="keyword">private</span> OffsetAndMetadata committed;  <span class="comment">// last committed position</span>
    <span class="keyword">private</span> <span class="keyword">boolean</span> paused;  <span class="comment">// whether this partition has been paused by the user</span>
    <span class="keyword">private</span> OffsetResetStrategy resetStrategy;  <span class="comment">// the strategy to use if the offset needs resetting</span></code></pre>

<blockquote>
<p>updateFetchPositions()  </p>
</blockquote>
<p>fetch positions if we have partitions we’re subscribed to that we don’t know the offset for<br>判断所有partition的offset是否有效，否则更新。</p>
<pre><code class="highlight java"> <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions())
        updateFetchPositions

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFetchPositions</span><span class="params">(Set&lt;TopicPartition&gt; partitions)</span> </span>&#123;
    <span class="comment">// lookup any positions for partitions which are awaiting reset</span>
fetcher.resetOffsetsIfNeeded(partitions);
    <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions(partitions)) &#123;
<span class="comment">// if we still don't have offsets for the given partitions, then we should either eek to the last committed position or reset using the auto reset policy</span>
    <span class="comment">// first refresh commits for all assigned partitions</span>
      coordinator.refreshCommittedOffsetsIfNeeded();
    <span class="comment">// then do any offset lookups in case some positions are not known</span>
        fetcher.updateFetchPositions(partitions);
    &#125;
&#125;</code></pre>

<blockquote>
<p>fetchedRecords()  </p>
</blockquote>
<p>Return the fetched records, empty the record buffer and update the consumed position.<br>NOTE: returning empty records guarantees the consumed position are NOT updated.<br>返回获取的记录，清空记录缓冲区并更新消费的位置(consumed position)<br>注意：返回空记录保证消费的位置不更新</p>
<pre><code class="highlight java"><span class="keyword">public</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetchedRecords() &#123;
  ..........
<span class="keyword">while</span> (recordsRemaining &gt; <span class="number">0</span>) &#123;
      ................
List&lt;ConsumerRecord&lt;K, V&gt;&gt; records=fetchRecords(nextInLineRecords,recordsRemaining);
<span class="keyword">if</span> (!records.isEmpty()) &#123;
      List&lt;ConsumerRecord&lt;K, V&gt;&gt; currentRecords = fetched.get(partition);
          <span class="keyword">if</span> (currentRecords == <span class="keyword">null</span>) &#123;
                    fetched.put(partition, records);
          &#125; <span class="keyword">else</span> &#123;
 <span class="comment">// this case shouldn't usually happen because we only send one fetch at a time per partition, but it might conceivably happen in some rare cases (such as partition leader changes). we have to copy to a new list because the old one may be immutable</span>
List&lt;ConsumerRecord&lt;K, V&gt;&gt; newRecords = <span class="keyword">new</span> ArrayList&lt;&gt;(records.size() + currentRecords.size());
                    newRecords.addAll(currentRecords);
                    newRecords.addAll(records);
                    fetched.put(partition, newRecords);
                &#125;
                recordsRemaining -= records.size();
            &#125;
        &#125;
    &#125;

    <span class="keyword">return</span> fetched;
&#125;</code></pre>

<blockquote>
<p>fetchRecords(nextInLineRecords, recordsRemaining)  </p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; fetchRecords(PartitionRecords partitionRecords, <span class="keyword">int</span> maxRecords) &#123;
   ..................
      <span class="keyword">long</span> position = subscriptions.position(partitionRecords.partition);
   ....................  
   <span class="keyword">if</span> (partitionRecords.nextFetchOffset == position) &#123;
List&lt;ConsumerRecord&lt;K, V&gt;&gt; partRecords = partitionRecords.fetchRecords(maxRecords);
  <span class="keyword">long</span> nextOffset = partitionRecords.nextFetchOffset;
  <span class="comment">//更新consumed position</span>
  subscriptions.position(partitionRecords.partition, nextOffset);
...........................
&#125;</code></pre>

<blockquote>
<p>client.poll(pollTimeout, now, new PollCondition()…)  </p>
</blockquote>
<p>Do actual reads and writes from sockets.</p>
<blockquote>
<p>sendFetches()  </p>
</blockquote>
<p>Set-up a fetch request for any node that we have assigned partitions for which doesn’t already have an in-flight fetch or pending fetch data.<br>发送新的抓取请求(不会发送等待处理的请求)。如未发送过fetch请求的分区节点或挂起数据的分区节点。partition的读写请求落于leader, leader落于一台broker。一个partition一个fetch请求。</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendFetches</span><span class="params">()</span> </span>&#123;
    Map&lt;Node, FetchRequest.Builder&gt; fetchRequestMap = createFetchRequests();
    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchRequest.Builder&gt; fetchEntry : fetchRequestMap.entrySet()) &#123;
        <span class="keyword">final</span> FetchRequest.Builder request = fetchEntry.getValue();
        <span class="keyword">final</span> Node fetchTarget = fetchEntry.getKey();
        client.send(fetchTarget, request)
                .addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;......&#125;);
&#125;
    <span class="keyword">return</span> fetchRequestMap.size();
&#125;</code></pre>

<blockquote>
<p>createFetchRequests()  </p>
</blockquote>
<p>Create fetch requests for all nodes for which we have assigned partitions that have no existing requests in flight.<br>创建fetch request</p>
<pre><code class="highlight java"><span class="keyword">private</span> Map&lt;Node, FetchRequest.Builder&gt; createFetchRequests() &#123;
    <span class="comment">// create the fetch info</span>
   .............
<span class="keyword">for</span> (TopicPartition partition : fetchablePartitions()) &#123;
.............
LinkedHashMap&lt;TopicPartition, FetchRequest.PartitionData&gt; fetch.......
fetchable.put(node, fetch);
.............
<span class="keyword">long</span> position = <span class="keyword">this</span>.subscriptions.position(partition);
<span class="comment">//fetch中放入此partition的last consumed position</span>
fetch.put(partition, <span class="keyword">new</span> FetchRequest.PartitionData(position, FetchRequest.INVALID_LOG_START_OFFSET, <span class="keyword">this</span>.fetchSize));
................
&#125;
<span class="comment">// create the fetches</span>
Map&lt;Node, FetchRequest.Builder&gt; requests = <span class="keyword">new</span> HashMap&lt;&gt;();
<span class="keyword">for</span> (Map.Entry&lt;Node, LinkedHashMap&lt;TopicPartition, FetchRequest.PartitionData&gt;&gt; entry : fetchable.entrySet()) &#123;
Node node = entry.getKey();
FetchRequest.Builder fetch = FetchRequest.Builder.forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, entry.getValue()).setMaxBytes(<span class="keyword">this</span>.maxBytes);
        requests.put(node, fetch);
&#125;
<span class="keyword">return</span> requests;&#125;</code></pre>

<blockquote>
<p>forConsumer(this.maxWaitMs…)  </p>
</blockquote>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">forConsumer</span><span class="params">(<span class="keyword">int</span> maxWait, <span class="keyword">int</span> minBytes, LinkedHashMap&lt;TopicPartition, PartitionData&gt; fetchData)</span> </span>&#123;
    <span class="keyword">return</span> <span class="keyword">new</span> Builder(<span class="keyword">null</span>, CONSUMER_REPLICA_ID, maxWait, minBytes, fetchData);
&#125;</code></pre>

</div>

		</div>
		
	</div>

	<!-- 引入代码高亮的 js -->
	
<script src="/lib/highlight/highlight.pack.js"></script>


	<!-- 引入 jquery -->
	
<script src="/lib/jquery-3.4.1.min.js"></script>


	<!-- 引入 pjax -->
	
<script src="/lib/jquery.pjax.js"></script>

	
	<!-- 引入 js 文件 -->
	
<script src="/js/main.js"></script>


	<!-- <script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.0.4/lib/L2Dwidget.min.js"></script>
	<script type="text/javascript">
	L2Dwidget.init();
	</script> -->

</body>
</html>