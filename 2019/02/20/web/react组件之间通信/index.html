<!DOCTYPE html>
<html>
<head>
	<title>Yoloz</title>
	<meta charset="utf-8">

	<!-- 引入配置文件 -->
	
<link rel="stylesheet" href="/css/main.css">


	<!-- 字体图片库 -->
	
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


	<!-- 代码高亮库 -->
	
<link rel="stylesheet" href="/lib/highlight/styles/atom-one-dark.css">

	
<meta name="generator" content="Hexo 4.2.0"></head>
<body>

	<div id="main">
		<!-- 引入侧边栏 -->
		<aside>
			<!-- 搜索栏 -->
<div id="search">
	<input class="search-input" type="text" placeholder="filter by name"/>
	<i id="search-icon" class="fa fa-bars" title="切换目录与索引"></i>
</div>

<!-- 侧边目录栏 -->
<div id="tree">
	

	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				db
			</a>
			
	<ul>
		<li class="file">
			<a href="/2020/02/20/db/mysql使用/">
				<i class="fa fa-file"></i>
				mysql使用
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2020/02/20/db/概述DQL,DML,DDL,DCL/">
				<i class="fa fa-file"></i>
				概述DQL,DML,DDL,DCL
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				hadoop
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/09/18/hadoop/hadoop-2.7.3单机搭建/">
				<i class="fa fa-file"></i>
				hadoop-2.7.3单机搭建
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/03/hadoop/hbase架构了解/">
				<i class="fa fa-file"></i>
				hbase架构了解
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/hadoop/hive-2.1.0单机搭建/">
				<i class="fa fa-file"></i>
				hive-2.1.0单机搭建
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				hexo
			</a>
			
	<ul>
		<li class="file">
			<a href="/2018/11/27/hexo/hexo搭建博客/">
				<i class="fa fa-file"></i>
				hexo搭建博客
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/27/hexo/start-hexo/">
				<i class="fa fa-file"></i>
				start-hexo
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				java
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/02/15/java/Xms-Xmx-XX:PermSize-XX:MaxPermSize区别/">
				<i class="fa fa-file"></i>
				Xms-Xmx-XX:PermSize-XX:MaxPermSize区别
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/07/30/java/date与localDateTime/">
				<i class="fa fa-file"></i>
				date与localDateTime
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/28/java/jar的使用/">
				<i class="fa fa-file"></i>
				jar的使用
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/14/java/java进程占用virt虚拟内存高的问题研究/">
				<i class="fa fa-file"></i>
				java进程占用virt虚拟内存高的问题研究
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/07/30/java/读取InputStream生成String/">
				<i class="fa fa-file"></i>
				读取InputStream生成String
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				kafka
			</a>
			
	<ul>
		<li class="file">
			<a href="/2018/12/11/kafka/consumerApi/">
				<i class="fa fa-file"></i>
				consumerApi
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/01/26/kafka/producer/">
				<i class="fa fa-file"></i>
				producer
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/01/23/kafka/sasl-plaintext-acl/">
				<i class="fa fa-file"></i>
				sasl-plaintext-acl
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				linux
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/07/24/linux/alternatives/">
				<i class="fa fa-file"></i>
				alternatives
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/30/linux/ps/">
				<i class="fa fa-file"></i>
				ps
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/linux/sh,exec,source/">
				<i class="fa fa-file"></i>
				sh,exec,source
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/04/linux/shell/">
				<i class="fa fa-file"></i>
				shell
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/11/13/linux/tcp连接数/">
				<i class="fa fa-file"></i>
				tcp连接数
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/11/13/linux/ulimit/">
				<i class="fa fa-file"></i>
				ulimit
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/linux/user,group/">
				<i class="fa fa-file"></i>
				user,group
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/30/linux/vi/">
				<i class="fa fa-file"></i>
				vi
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/09/18/linux/which,whereis,locate,find/">
				<i class="fa fa-file"></i>
				which,whereis,locate,find
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				lucene
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/02/18/lucene/Lucene的Index文档模型/">
				<i class="fa fa-file"></i>
				Lucene的Index文档模型
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				other
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/02/15/other/五种开源协议(GPL,LGPL,BSD,MIT,Apache)/">
				<i class="fa fa-file"></i>
				五种开源协议(GPL,LGPL,BSD,MIT,Apache)
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				tools
			</a>
			
	<ul>
		<li class="file">
			<a href="/2018/12/10/tools/git/">
				<i class="fa fa-file"></i>
				git
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/12/05/tools/svn/">
				<i class="fa fa-file"></i>
				svn
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2019/02/19/tools/yaml格式/">
				<i class="fa fa-file"></i>
				yaml格式
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				web
			</a>
			
	<ul>
		<li class="file">
			<a href="/2019/02/20/web/javaScript遍历对象、数组/">
				<i class="fa fa-file"></i>
				javaScript遍历对象、数组
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file">
			<a href="/2018/11/29/web/react-loadable代码分割/">
				<i class="fa fa-file"></i>
				react-loadable代码分割
			</a>
		</li>
	</ul>
	
	<ul>
		<li class="file active">
			<a href="/2019/02/20/web/react组件之间通信/">
				<i class="fa fa-file"></i>
				react组件之间通信
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
</div>


<!-- 展示文章内部标题 -->
<div id="toc" style="display: none;">
</div>
		</aside>

		<!-- 引入导航 -->
		<nav>
			<div class="container-fluid">
    <ul id="menu">
        
        
        <li class="menu-item">
            <a href="/" class="menu-item-link">主页</a>
        </li>
        
        <li class="menu-item">
            <a href="/about" class="menu-item-link">关于</a>
        </li>
        

        
        
        <li class="menu-item">
            <a href="https://github.com/yoloz" class="menu-item-link" target="_blank">github</a>
        </li>
        
    </ul>
</div>
		</nav>

		<!-- 引入正文 -->
		<div id="content">
			<div style="background: #eee">
	<span id="post-author">yoloz</span>
	<span id="post-date">2019-02-20 16:08:39</span>
</div>

<div id="article">
	<p>在React组件中，props是父组件与子组件的唯一通信方式，但是在某些情况下我们需要在props之外强制修改子组件或DOM元素，这种情况下React提供了Refs解决。</p>
<blockquote>
<p>如果能使用props实现，应该尽量避免使用refs实现。</p>
</blockquote>
<h2 id="Refs三种方式"><a href="#Refs三种方式" class="headerlink" title="Refs三种方式"></a>Refs三种方式</h2><ul>
<li>字符串模式 ：废弃不建议使用</li>
<li>回调函数</li>
<li>React.createRef()：React16.3提供</li>
</ul>
<h2 id="字符串模式"><a href="#字符串模式" class="headerlink" title="字符串模式"></a>字符串模式</h2><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;
  <span class="keyword">constructor</span>(props, context) &#123;
    <span class="keyword">super</span>(props, context);
  &#125;
  componentDidMount()&#123;
    <span class="keyword">this</span>.refs.inputEl.focus();
  &#125;
  render() &#123;
    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.props;
    <span class="keyword">return</span> (
        &lt;input ref=<span class="string">"inputEl"</span>/&gt;
    );
  &#125;
&#125;</code></pre>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li>针对静态类型检测不支持</li>
<li>对复杂用例难以实现：需要向父组件暴露dom；单个实例绑定多个dom</li>
<li>绑定到的实例，是执行render方法的实例，结果会让人很意外，例如：</li>
</ul>
<pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;
  render() &#123;
    <span class="keyword">const</span> &#123; renderer &#125; = <span class="keyword">this</span>.props;
    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;renderer(1)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;
  &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;
  render() &#123;
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"App"</span>&gt;
        &lt;Child renderer=&#123;index =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"test"</span>&gt;</span>&#123;index&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125; /&gt;
      &lt;<span class="regexp">/div&gt;</span>
<span class="regexp">    );</span>
<span class="regexp">  &#125;</span>
<span class="regexp">&#125;</span></code></pre>

<blockquote>
<p>上面这种情况，会导致test绑定的实例是Child上面，并不是App上。</p>
</blockquote>
<h2 id="回调函数模式"><a href="#回调函数模式" class="headerlink" title="回调函数模式"></a>回调函数模式</h2><p>相比字符串模式更加灵活，也避免了诸多问题。</p>
<ul>
<li>可以优雅在组件销毁时回收变量, ref中的回调函数会在对应的普通组件componentDidMount，ComponentDidUpdate之前; 或者componentWillUnmount之后执行，componentWillUnmount之后执行时，callback接收到的参数是null。</li>
<li>很好的支持静态类型检测。</li>
<li>针对数组遍历时可以直接转换为对应的数组，看下面的例子：</li>
</ul>
<pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;
  <span class="keyword">constructor</span>(props, context) &#123;
    <span class="keyword">super</span>(props, context);
  &#125;
  _ref = <span class="function"><span class="params">el</span> =&gt;</span> &#123;
    <span class="keyword">if</span> (el) &#123;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.els) &#123;
        <span class="keyword">this</span>.els = [];
      &#125;
      <span class="keyword">this</span>.els.push(el);
    &#125; <span class="keyword">else</span> &#123;
      <span class="keyword">this</span>.els = [];
    &#125;
  &#125;;
  render() &#123;
    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.props;
    <span class="keyword">return</span> (
      &lt;ul&gt;
        &#123;list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;
          <span class="keyword">return</span> (
            &lt;li ref=&#123;<span class="keyword">this</span>._ref&#125; key=&#123;index&#125;&gt;
              &#123;item&#125;
            &lt;<span class="regexp">/li&gt;</span>
<span class="regexp">          );</span>
<span class="regexp">        &#125;)&#125;</span>
<span class="regexp">      &lt;/u</span>l&gt;
    );
  &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;
  state = &#123;
    value: <span class="string">""</span>,
    list: []
  &#125;;
  onChange = <span class="function">(<span class="params">&#123; target: &#123; value &#125; &#125;</span>) =&gt;</span> &#123;
    <span class="keyword">this</span>.setState(&#123; value &#125;);
  &#125;;
  add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;
    <span class="keyword">const</span> &#123; list, value &#125; = <span class="keyword">this</span>.state;
    list.push(value);
    <span class="keyword">this</span>.setState(&#123;
      value: <span class="string">""</span>,
      list
    &#125;);
  &#125;;
  render() &#123;
    <span class="keyword">const</span> &#123; value, list &#125; = <span class="keyword">this</span>.state;
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"App"</span>&gt;
        &lt;input value=&#123;value&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125; /&gt;
        &lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;add&lt;<span class="regexp">/button&gt;</span>
<span class="regexp">        &lt;List list=&#123;list&#125; /</span>&gt;
      &lt;<span class="regexp">/div&gt;</span>
<span class="regexp">    );</span>
<span class="regexp">  &#125;</span>
<span class="regexp">&#125;</span></code></pre>

<ul>
<li>可以将父组件的ref传入孙组件，虽然不建议这么使用（破坏组件封装）。</li>
</ul>
<pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">props</span>) </span>&#123;
  <span class="keyword">return</span> (
    &lt;div&gt;
      &lt;input ref=&#123;props.inputRef&#125; /&gt;
    &lt;<span class="regexp">/div&gt;</span>
<span class="regexp">  );</span>
<span class="regexp">&#125;</span>
<span class="regexp"></span>
<span class="regexp">class InputBox extends React.Component &#123;</span>
<span class="regexp"> _ref = (el)=&gt;&#123;</span>
<span class="regexp">     this.inputElement = el</span>
<span class="regexp"> &#125;</span>
<span class="regexp">  render() &#123;</span>
<span class="regexp">    return (</span>
<span class="regexp">      &lt;Input</span>
<span class="regexp">        inputRef=&#123;this._ref&#125;</span>
<span class="regexp">      /</span>&gt;
    );
  &#125;
&#125;</code></pre>

<h3 id="同样存在弊端"><a href="#同样存在弊端" class="headerlink" title="同样存在弊端"></a>同样存在弊端</h3><p>通常为了绑定一个组件（元素）实例到当前实例上需要写一个函数，代码结构上看起来很冗余，为了一个变量，使用一个函数去绑定，每一个绑定组件（元素）都需要一个方法处理，大材小用。因此React提供了更简单有效的解决方案 <code>React.createRef()</code> 。</p>
<h2 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef()"></a>React.createRef()</h2><p>使用React.createRef()创建refs，通过ref属性来获得React元素。当构造组件时，refs通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们.</p>
<pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;
    myRef = React.createRef();
    componentDidMount()&#123;
      <span class="comment">// 访问ref</span>
      <span class="keyword">const</span> dom = <span class="keyword">this</span>.myRef.current
    &#125;
    render()&#123;
        <span class="keyword">return</span> (
            &lt;div ref=&#123;<span class="keyword">this</span>.myRef&#125;/&gt;
        )
    &#125;
&#125;</code></pre>

<p>ref的值取决于节点的类型:</p>
<ul>
<li>当ref属性被用于一个普通的HTML元素时，React.createRef()将接收底层DOM元素作为它的current属性以创建ref 。</li>
<li>当ref属性被用于一个自定义类组件时，ref对象将接收该组件已挂载的实例作为它的current 。</li>
<li>你不能在函数式组件上使用ref属性，因为它们没有实例。</li>
</ul>
<h3 id="refs传递"><a href="#refs传递" class="headerlink" title="refs传递"></a>refs传递</h3><p>将父组件ref作为一个props传入，在子组件显示调用</p>
<pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;
    render()&#123;
        <span class="keyword">const</span> &#123;forwardRef&#125; = <span class="keyword">this</span>.props;
        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;forwardRef&#125;/</span>&gt;</span></span>
    &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">Sup</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;
    subRef = React.createRef();
    render()&#123;
        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Sub</span> <span class="attr">forwardRef</span>=<span class="string">&#123;this.subRef&#125;/</span>&gt;</span></span>
    &#125;
&#125;</code></pre>

<h2 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef()"></a>React.forwardRef()</h2><p>React.forwardRef方式，对于使用组件者来说，ref是透明的，不需要额外定一个props传入，直接传递到了下级组件，作为高阶组件封装时，这样做更加友好。</p>
<pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;
    render()&#123;
        <span class="keyword">const</span> &#123;forwardRef&#125; = <span class="keyword">this</span>.props;
        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;forwardRef&#125;/</span>&gt;</span></span>
    &#125;
&#125;

<span class="function"><span class="keyword">function</span> <span class="title">forwardRef</span>(<span class="params">props, ref</span>)</span>&#123;
    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Sup</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;/</span>&gt;</span></span>
&#125;
<span class="comment">// 为了devtool中展示有意义的组件名称</span>
forwardRef.displayName=<span class="string">`forwardRef-<span class="subst">$&#123;Component.displayName||Component.name&#125;</span>`</span>

<span class="keyword">const</span> XSub = React.forwardRef(forwardRef);

<span class="class"><span class="keyword">class</span> <span class="title">Sup</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;
    _ref=<span class="function">(<span class="params">el</span>)=&gt;</span>&#123;<span class="keyword">this</span>.subEl =el&#125;;
    render()&#123;
        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">XSub</span> <span class="attr">ref</span>=<span class="string">&#123;this._ref&#125;/</span>&gt;</span></span>
    &#125;
&#125;</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Refs字符串模式已经废弃，React不建议使用并且会提示警告，开发中推荐使用React.forwardRef方式，简单优雅，回调函数模式应用在复杂场景中。<br>上述内容来自<a href="https://imweb.io/topic/5b6136a06025939b125f45ff" target="_blank" rel="noopener">浅谈 React Refs</a></p>
<h2 id="onRef"><a href="#onRef" class="headerlink" title="onRef"></a>onRef</h2><p>如果Parent调用Child下的Child(或更多)，Child及它的Child同样添加onRef，然后Parent里面 <code>let tableData = this.child.child.child.state.data;</code> 这样取值。如下:</p>
<pre><code class="highlight js"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;
<span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;
    render() &#123;
        <span class="keyword">return</span>(
            &lt;div&gt;
                &lt;Child onRef=&#123;<span class="keyword">this</span>.onRef&#125; /&gt;
                &lt;button onClick=&#123;<span class="keyword">this</span>.click&#125; &gt;click&lt;<span class="regexp">/button&gt;</span>
<span class="regexp">            &lt;/</span>div&gt;
        )
    &#125;
    onRef = <span class="function">(<span class="params">ref</span>) =&gt;</span> &#123;
        <span class="keyword">this</span>.child = ref
    &#125;
    click = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;
        <span class="keyword">this</span>.child.myName()
    &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;
    componentDidMount()&#123;
        <span class="keyword">this</span>.props.onRef(<span class="keyword">this</span>)
    &#125;
    myName = <span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">"组件之间通信成功"</span>);
    render() &#123;
        <span class="keyword">return</span> ();
    &#125;
&#125;</code></pre>

</div>

		</div>
		
	</div>

	<!-- 引入代码高亮的 js -->
	
<script src="/lib/highlight/highlight.pack.js"></script>


	<!-- 引入 jquery -->
	
<script src="/lib/jquery-3.4.1.min.js"></script>


	<!-- 引入 pjax -->
	
<script src="/lib/jquery.pjax.js"></script>

	
	<!-- 引入 js 文件 -->
	
<script src="/js/main.js"></script>


	<!-- <script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.0.4/lib/L2Dwidget.min.js"></script>
	<script type="text/javascript">
	L2Dwidget.init();
	</script> -->

</body>
</html>