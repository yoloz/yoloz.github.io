<!DOCTYPE html>
<html>

<head>
	<title>Yoloz</title>
	<meta charset="utf-8">
	<!-- <meta name="viewport" content="width=1024,initial-scale=0.68, minimum-scale=0.1, maximum-scale=1.0"/>
	<meta name="viewport" content="width=800,initial-scale=0.51, minimum-scale=0.1, maximum-scale=1.0"/> -->
	<meta name="viewport" content="width=400,initial-scale=0.25, minimum-scale=0.1, maximum-scale=1.0" />
	<!-- 引入配置文件 -->
	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="/css/index.css">

	
<link rel="stylesheet" href="/css/tree.css">

	
<link rel="stylesheet" href="/css/post.css">

	
<link rel="stylesheet" href="/css/toc.css">

	<!-- 字体图片库 -->
	
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


	<!-- 代码高亮库 -->
	
<link rel="stylesheet" href="/lib/highlight/styles/atom-one-dark.css">


<meta name="generator" content="Hexo 4.2.0"></head>

<body>
	<div id="container">
		<header id="header" class="wrapper">
			<div id="header-inner" class="inner">
				<nav id="main-nav">
    
    
    <a href="/" class="main-nav-link">主页</a>
    
    <a href="/about" class="main-nav-link">关于</a>
    

    
    
    <a target="_blank" href="https://github.com/yoloz" rel="external nofollow noreferrer noopener"
        class="main-nav-link"><i class="fa fa-github-alt"></i></a>
    <div id="search-input-icon">
        <i class="fa fa-search"></i>
    </div>
    <span style="position: relative; display: inline-block; direction: ltr;"><input type="search" id="search-input"
            placeholder="Search..." autocomplete="off" style="position: relative; vertical-align: top;">
    </span>
</nav>
			</div>
		</header>
		<div id="content-wrap">
			<div id="content" class="wrapper">
				<aside id="sidebar" role="navigation">
					<div class="inner">
						<!-- 侧边目录栏 -->
<div id="tree">
	

	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				database
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/20/database/mysql使用/">
				<i class="fa fa-file"></i>
				mysql使用
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/20/database/概述DQL,DML,DDL,DCL/">
				<i class="fa fa-file"></i>
				概述DQL,DML,DDL,DCL
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				hadoop
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/05/20/hadoop/CDH概念验证安装/">
				<i class="fa fa-file"></i>
				CDH概念验证安装
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/09/18/hadoop/hadoop-2.7.3单机搭建/">
				<i class="fa fa-file"></i>
				hadoop-2.7.3单机搭建
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/05/18/hadoop/hbase-2.2.4伪分布式/">
				<i class="fa fa-file"></i>
				hbase-2.2.4伪分布式
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/12/03/hadoop/hbase架构了解/">
				<i class="fa fa-file"></i>
				hbase架构了解
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/09/18/hadoop/hive-2.1.0单机搭建/">
				<i class="fa fa-file"></i>
				hive-2.1.0单机搭建
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				java
			</a>
			
	<ul style="display: none;">
		<li class="file active">
			<a href="/2020/04/01/java/CompletableFuture详解/">
				<i class="fa fa-file"></i>
				CompletableFuture详解
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/03/10/java/JVM调式工具/">
				<i class="fa fa-file"></i>
				JVM调式工具
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/28/java/ReentrantLock/">
				<i class="fa fa-file"></i>
				ReentrantLock
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/07/30/java/date与localDateTime/">
				<i class="fa fa-file"></i>
				date与localDateTime
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/11/28/java/java,javac,jar命令/">
				<i class="fa fa-file"></i>
				java,javac,jar命令
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/03/10/java/javaThreadDump日志分析/">
				<i class="fa fa-file"></i>
				javaThreadDump日志分析
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/12/14/java/java进程占用virt虚拟内存高的问题研究/">
				<i class="fa fa-file"></i>
				java进程占用virt虚拟内存高的问题研究
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/02/15/java/jvm启动参数/">
				<i class="fa fa-file"></i>
				jvm启动参数
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/07/30/java/读取InputStream生成String/">
				<i class="fa fa-file"></i>
				读取InputStream生成String
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				kafka
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/12/11/kafka/consumerApi/">
				<i class="fa fa-file"></i>
				consumerApi
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/01/26/kafka/producer/">
				<i class="fa fa-file"></i>
				producer
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/01/23/kafka/sasl-plaintext-acl/">
				<i class="fa fa-file"></i>
				sasl-plaintext-acl
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				linux
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/29/linux/DNS/">
				<i class="fa fa-file"></i>
				DNS
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/03/19/linux/Locale/">
				<i class="fa fa-file"></i>
				Locale
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/07/24/linux/alternatives/">
				<i class="fa fa-file"></i>
				alternatives
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/26/linux/du,df/">
				<i class="fa fa-file"></i>
				du,df
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/03/11/linux/killall,kill,pkill/">
				<i class="fa fa-file"></i>
				killall,kill,pkill
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/03/10/linux/ncat(nc)/">
				<i class="fa fa-file"></i>
				ncat(nc)
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/11/30/linux/ps/">
				<i class="fa fa-file"></i>
				ps
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/09/18/linux/shell中sh, exec, source, fork的区别/">
				<i class="fa fa-file"></i>
				shell中sh, exec, source, fork的区别
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/26/linux/ssh/">
				<i class="fa fa-file"></i>
				ssh
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/11/13/linux/tcp连接数/">
				<i class="fa fa-file"></i>
				tcp连接数
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/11/13/linux/ulimit/">
				<i class="fa fa-file"></i>
				ulimit
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/11/30/linux/vim/">
				<i class="fa fa-file"></i>
				vim
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/09/18/linux/which,whereis,locate,find/">
				<i class="fa fa-file"></i>
				which,whereis,locate,find
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/29/linux/服务自启动/">
				<i class="fa fa-file"></i>
				服务自启动
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/09/18/linux/用户及组/">
				<i class="fa fa-file"></i>
				用户及组
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/12/04/linux/编写shell/">
				<i class="fa fa-file"></i>
				编写shell
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/29/linux/静态ip地址/">
				<i class="fa fa-file"></i>
				静态ip地址
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				lucene
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/02/18/lucene/Lucene的Index文档模型/">
				<i class="fa fa-file"></i>
				Lucene的Index文档模型
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				network
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/23/network/TCPIP常見封包/">
				<i class="fa fa-file"></i>
				TCPIP常見封包
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/23/network/cksum(checksum)incorrect/">
				<i class="fa fa-file"></i>
				cksum(checksum)incorrect
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/03/10/network/tcp_timestamps/">
				<i class="fa fa-file"></i>
				tcp_timestamps
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/23/network/tcpdump/">
				<i class="fa fa-file"></i>
				tcpdump
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				other
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/12/10/other/git/">
				<i class="fa fa-file"></i>
				git
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/11/27/other/hexo搭建博客/">
				<i class="fa fa-file"></i>
				hexo搭建博客
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/11/27/other/start-hexo/">
				<i class="fa fa-file"></i>
				start-hexo
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/12/05/other/svn/">
				<i class="fa fa-file"></i>
				svn
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/02/19/other/yaml格式/">
				<i class="fa fa-file"></i>
				yaml格式
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/02/15/other/五种开源协议(GPL,LGPL,BSD,MIT,Apache)/">
				<i class="fa fa-file"></i>
				五种开源协议(GPL,LGPL,BSD,MIT,Apache)
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				security
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/04/18/security/SSL双向认证实现/">
				<i class="fa fa-file"></i>
				SSL双向认证实现
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/04/17/security/X.509数字证书中的扩展项/">
				<i class="fa fa-file"></i>
				X.509数字证书中的扩展项
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/04/17/security/keytool命令详解/">
				<i class="fa fa-file"></i>
				keytool命令详解
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
	<ul>
		<li class="directory">
			<a href="#" class="directory">
				<i class="fa fa-folder"></i>
				web
			</a>
			
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/02/20/web/javaScript遍历对象、数组/">
				<i class="fa fa-file"></i>
				javaScript遍历对象、数组
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2020/02/29/web/npm,nvm,nrm,npx,cnpm/">
				<i class="fa fa-file"></i>
				npm,nvm,nrm,npx,cnpm
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2018/11/29/web/react-loadable代码分割/">
				<i class="fa fa-file"></i>
				react-loadable代码分割
			</a>
		</li>
	</ul>
	
	<ul style="display: none;">
		<li class="file">
			<a href="/2019/02/20/web/react组件之间通信/">
				<i class="fa fa-file"></i>
				react组件之间通信
			</a>
		</li>
	</ul>
	
		</li>

	</ul>
	
</div>
					</div>
				</aside>
				<div id="content-inner">
					<article class="article-container" itemscope="" itemtype="http://schema.org/Article">
						<aside id="article-toc" role="navigation">
							<div id="article-toc-inner">
								<strong class="sidebar-title">目录</strong>
								<ol class="toc">
								</ol>
								<a href="#" id="article-toc-top">回到顶部</a>
							</div>
						</aside>
						<div class="article-inner">
							<span id="post-author">yoloz</span>
<span id="post-date">2020-04-01 17:20:34</span>
<div id="post-content">
	<h2 id="常用多线程并发，取结果归集的几种实现方案"><a href="#常用多线程并发，取结果归集的几种实现方案" class="headerlink" title="常用多线程并发，取结果归集的几种实现方案"></a>常用多线程并发，取结果归集的几种实现方案</h2><table>
<thead>
<tr>
<th align="left">描述</th>
<th align="left">Future</th>
<th align="left">FutureTask</th>
<th align="left">CompletionService</th>
<th align="left">CompletableFuture</th>
</tr>
</thead>
<tbody><tr>
<td align="left">原理</td>
<td align="left">Future接口</td>
<td align="left">接口RunnableFuture的唯一实现类，RunnableFuture接口继承自Future+Runnable</td>
<td align="left">内部通过阻塞队列+FutureTask接口</td>
<td align="left">JDK8实现了Future, CompletionStage两个接口</td>
</tr>
<tr>
<td align="left">多任务并发执行</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">获取任务结果的顺序</td>
<td align="left">按照提交顺序获取结果</td>
<td align="left">未知</td>
<td align="left">支持任务完成的先后顺序</td>
<td align="left">支持任务完成的先后顺序</td>
</tr>
<tr>
<td align="left">异常捕捉</td>
<td align="left">自己捕捉</td>
<td align="left">自己捕捉</td>
<td align="left">自己捕捉</td>
<td align="left">原生API支持，返回每个任务的异常</td>
</tr>
<tr>
<td align="left">建议</td>
<td align="left">CPU高速轮询，耗资源，可以使用，但不推荐</td>
<td align="left">功能不对口，并发任务这一块多套一层，不推荐使用</td>
<td align="left">推荐使用，没有JDK8CompletableFuture之前最好的方案，没有质疑</td>
<td align="left">API极端丰富，配合流式编程，速度飞起，推荐使用！</td>
</tr>
</tbody></table>
<p>Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFuture</span> </span>&#123;
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;
        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);
        Future&lt;Integer&gt; f = es.submit(() -&gt;&#123;
                <span class="comment">// 长时间的异步计算</span>
                <span class="comment">// ……</span>
                <span class="comment">// 然后返回结果</span>
                <span class="keyword">return</span> <span class="number">100</span>;
            &#125;);
<span class="comment">//        while(!f.isDone())</span>
<span class="comment">//            ;</span>
        f.get();
    &#125;
&#125;</code></pre>

<p>虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？</p>
<p>很多语言，比如Node.js，采用回调的方式实现异步编程。Java的一些框架，比如Netty，自己扩展了Java的 Future接口，提供了addListener等多个扩展方法：</p>
<pre><code class="highlight java">ChannelFuture future = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(host, port));
      future.addListener(<span class="keyword">new</span> ChannelFutureListener()
      &#123;
              <span class="meta">@Override</span>
              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception</span>
<span class="function">              </span>&#123;
                  <span class="keyword">if</span> (future.isSuccess()) &#123;
                      <span class="comment">// SUCCESS</span>
                  &#125;
                  <span class="keyword">else</span> &#123;
                      <span class="comment">// FAILURE</span>
                  &#125;
              &#125;
      &#125;);</code></pre>

<p>Google guava也提供了通用的扩展Future:ListenableFuture、SettableFuture 以及辅助类Futures等,方便异步编程。</p>
<pre><code class="highlight java"><span class="keyword">final</span> String name = ...;
inFlight.add(name);
ListenableFuture&lt;Result&gt; future = service.query(name);
future.addListener(<span class="keyword">new</span> Runnable() &#123;
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;
    processedCount.incrementAndGet();
    inFlight.remove(name);
    lastProcessed.set(name);
    logger.info(<span class="string">"Done with &#123;0&#125;"</span>, name);
  &#125;
&#125;, executor);</code></pre>

<p>Scala也提供了简单易用且功能强大的Future/Promise异步编程模式。</p>
<p>作为正统的Java类库，是不是应该做点什么，加强一下自身库的功能呢？</p>
<p>在Java 8中, 新增加了一个包含50个方法左右的类: CompletableFuture，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>
<h2 id="主动完成计算"><a href="#主动完成计算" class="headerlink" title="主动完成计算"></a>主动完成计算</h2><p>CompletableFuture类实现了CompletionStage和Future接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> T 	<span class="title">get</span><span class="params">()</span></span>
<span class="function"><span class="keyword">public</span> T 	<span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>
<span class="function"><span class="keyword">public</span> T 	<span class="title">getNow</span><span class="params">(T valueIfAbsent)</span></span>
<span class="function"><span class="keyword">public</span> T 	<span class="title">join</span><span class="params">()</span></span></code></pre>

<p>getNow有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的valueIfAbsent值。</p>
<p>join返回计算的结果或者抛出一个unchecked异常(CompletionException)，它和get对抛出的异常的处理有些细微的区别，你可以运行下面的代码进行比较：</p>
<pre><code class="highlight java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
<span class="comment">//future.join();</span>
future.get();</code></pre>

<p>尽管Future可以代表在另外的线程中执行的一段异步代码，但是你还是可以在本身线程中执行：</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Integer&gt; <span class="title">compute</span><span class="params">()</span> </span>&#123;
    <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();
    <span class="keyword">return</span> future;
&#125;</code></pre>

<p>上面的代码中future没有关联任何的Callback、线程池、异步任务等，如果客户端调用future.get就会一致傻等下去。你可以通过下面的代码完成一个计算，触发客户端的等待：<code>f.complete(100);</code>,当然你也可以抛出一个异常，而不是一个成功的计算结果：<code>f.completeExceptionally(new Exception());</code>。完整的代码如下：</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicMain</span> </span>&#123;
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Integer&gt; <span class="title">compute</span><span class="params">()</span> </span>&#123;
        <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();
        <span class="keyword">return</span> future;
    &#125;
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;
        <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; f = compute();
        <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;
            CompletableFuture&lt;Integer&gt; f;
            Client(String threadName, CompletableFuture&lt;Integer&gt; f) &#123;
                <span class="keyword">super</span>(threadName);
                <span class="keyword">this</span>.f = f;
            &#125;
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;
                <span class="keyword">try</span> &#123;
                    System.out.println(<span class="keyword">this</span>.getName() + <span class="string">": "</span> + f.get());
                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        <span class="keyword">new</span> Client(<span class="string">"Client1"</span>, f).start();
        <span class="keyword">new</span> Client(<span class="string">"Client2"</span>, f).start();
        System.out.println(<span class="string">"waiting"</span>);
        f.complete(<span class="number">100</span>);
        <span class="comment">//f.completeExceptionally(new Exception());</span>
        System.in.read();
    &#125;
&#125;</code></pre>

<p>可以看到我们并没有把f.complete(100);放在另外的线程中去执行，但是在大部分情况下我们可能会用一个线程池去执行这些异步任务。CompletableFuture.complete()、CompletableFuture.completeExceptionally只能被调用一次。但是我们有两个后门方法可以重设这个值:obtrudeValue、obtrudeException，但是使用的时候要小心，因为complete已经触发了客户端，有可能导致客户端会得到不期望的结果。</p>
<h2 id="创建CompletableFuture对象"><a href="#创建CompletableFuture对象" class="headerlink" title="创建CompletableFuture对象"></a>创建CompletableFuture对象</h2><p>CompletableFuture.completedFuture是一个静态辅助方法，用来返回一个已经计算好的CompletableFuture。</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span></span></code></pre>

<p>而以下四个静态方法用来为一段异步执行的代码创建CompletableFuture对象：</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; 	<span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; 	<span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></code></pre>

<p>以Async结尾并且没有指定Executor的方法会使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</p>
<p>runAsync方法也好理解，它以Runnable函数式接口类型为参数，所以CompletableFuture的计算结果为空。</p>
<p>supplyAsync方法以Supplier&lt;U&gt;函数式接口类型为参数,CompletableFuture的计算结果类型为U。</p>
<p>因为方法的参数类型都是函数式接口，所以可以使用lambda表达式实现异步任务，比如：</p>
<pre><code class="highlight java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="comment">//长时间的计算任务</span>
    <span class="keyword">return</span> <span class="string">"·00"</span>;
&#125;);</code></pre>

<h2 id="计算结果完成时的处理"><a href="#计算结果完成时的处理" class="headerlink" title="计算结果完成时的处理"></a>计算结果完成时的处理</h2><p>当CompletableFuture的计算结果完成，或者抛出异常的时候，我们可以执行特定的Action。主要是下面的方法：</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; 	<span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; 	<span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; 	<span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt;     <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span></span></code></pre>

<p>可以看到Action的类型是BiConsumer&lt;? super T,? super Throwable&gt;，它可以处理正常的计算结果，或者异常情况。<br>方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。</p>
<blockquote>
<p>注意这几个方法都会返回CompletableFuture，当Action执行完毕后它的结果返回原始的CompletableFuture的计算结果或者返回异常。</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;
    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random();
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> t = System.currentTimeMillis();
    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMoreData</span><span class="params">()</span> </span>&#123;
        System.out.println(<span class="string">"begin to start compute"</span>);
        <span class="keyword">try</span> &#123;
            Thread.sleep(<span class="number">10000</span>);
        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
        &#125;
        System.out.println(<span class="string">"end to start compute. passed "</span> + (System.currentTimeMillis() - t)/<span class="number">1000</span> + <span class="string">" seconds"</span>);
        <span class="keyword">return</span> rand.nextInt(<span class="number">1000</span>);
    &#125;
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;
        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);
        Future&lt;Integer&gt; f = future.whenComplete((v, e) -&gt; &#123;
            System.out.println(v);
            System.out.println(e);
        &#125;);
        System.out.println(f.get());
        System.in.read();
    &#125;
&#125;</code></pre>

<p>下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由BiFunction参数计算而得。因此这组方法兼有whenComplete和转换的两个功能。</p>
<pre><code class="highlight java"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; 	<span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn, Executor executor)</span></span></code></pre>

<p>同样，不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>CompletableFuture可以作为monad(单子)和functor。由于回调风格的实现，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉CompletableFuture当计算完成的时候请执行某个function。而且我们还可以将这些操作串联起来，或者将CompletableFuture组合起来。</p>
<pre><code class="highlight java"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span></code></pre>

<p>这一组函数的功能是当原来的CompletableFuture计算完后，将结果传递给函数fn，将fn的结果作为新的CompletableFuture计算结果。因此它的功能相当于将CompletableFuture<T>转换成CompletableFuture&lt;U&gt;。</p>
<p>这三个函数的区别和上面介绍的一样，不以Async结尾的方法由原来的线程计算，以Async结尾的方法由默认的线程池ForkJoinPool.commonPool()或者指定的线程池executor运行。Java的CompletableFuture类总是遵循这样的原则，下面就不一一赘述了。</p>
<p>使用例子如下：</p>
<pre><code class="highlight java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;String&gt; f =  future.thenApplyAsync(i -&gt; i * <span class="number">10</span>).thenApply(i -&gt; i.toString());
System.out.println(f.get()); <span class="comment">//"1000"</span></code></pre>

<blockquote>
<p>需要注意的是，这些转换并不是马上执行的，也不会阻塞，而是在前一个stage完成后继续执行。</p>
</blockquote>
<p><strong>它们与handle方法的区别在于handle方法会处理正常计算值和异常，因此它可以屏蔽异常，避免异常继续抛出。而thenApply方法只是用来处理正常值，因此一旦有异常就会抛出.</strong></p>
<h2 id="纯消费-执行Action"><a href="#纯消费-执行Action" class="headerlink" title="纯消费(执行Action)"></a>纯消费(执行Action)</h2><p>上面的方法是当计算完成的时候，会生成新的计算结果(thenApply, handle)，或者返回同样的计算结果whenComplete，CompletableFuture还提供了一种处理结果的方法，只对结果执行Action,而不返回新的计算值，因此计算值为Void:</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></code></pre>

<p>看它的参数类型也就明白了，它们是函数式接口Consumer，这个接口只有输入，没有返回值。</p>
<pre><code class="highlight java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;Void&gt; f =  future.thenAccept(System.out::println);
System.out.println(f.get());</code></pre>

<p>thenAcceptBoth以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的action，它用来组合另外一个异步的结果。</p>
<p>runAfterBoth是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。</p>
<pre><code class="highlight java"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action, Executor executor)</span></span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,  Runnable action)</span></span></code></pre>

<p>例子如下：</p>
<pre><code class="highlight java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;Void&gt; f =  future.thenAcceptBoth(CompletableFuture.completedFuture(<span class="number">10</span>), (x, y) -&gt; System.out.println(x * y));
System.out.println(f.get());</code></pre>

<p>更彻底地，下面一组方法当计算完成的时候会执行一个Runnable,与thenAccept不同，Runnable并不使用CompletableFuture计算的结果。</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenRun</span><span class="params">(Runnable action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span></code></pre>

<p>因此先前的CompletableFuture计算的结果被忽略了,这个方法返回CompletableFuture<Void>类型的对象。</p>
<pre><code class="highlight java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;Void&gt; f =  future.thenRun(() -&gt; System.out.println(<span class="string">"finished"</span>));
System.out.println(f.get());</code></pre>

<blockquote>
<p>Runnable类型的参数会忽略计算的结果<br>Consumer是纯消费计算结果<br>BiConsumer会组合另外一个CompletionStage纯消费<br>Function会对计算结果做转换<br>BiFunction会组合另外一个CompletionStage的计算结果做转换</p>
</blockquote>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><pre><code class="highlight java"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span></code></pre>

<p>这一组方法接受一个Function作为参数，这个Function的输入是当前的CompletableFuture的计算值，返回结果将是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。因此它的功能类似:<code>A +--&gt; B +---&gt; C</code></p>
<blockquote>
<p>记住，thenCompose返回的对象并不一是函数fn返回的对象，如果原来的CompletableFuture还没有计算出来，它就会生成一个新的组合后的CompletableFuture。</p>
</blockquote>
<p>例子：</p>
<pre><code class="highlight java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;String&gt; f =  future.thenCompose( i -&gt; &#123;
    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;
        <span class="keyword">return</span> (i * <span class="number">10</span>) + <span class="string">""</span>;
    &#125;);
&#125;);
System.out.println(f.get()); <span class="comment">//1000</span></code></pre>

<p>而下面的一组方法thenCombine用来复合另外一个CompletionStage的结果。它的功能类似：</p>
<pre><code class="highlight java">#A +
#  |
#  +------&gt; C
#  +------^
#B +

<span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, </span></span>
<span class="function"><span class="params">Executor executor)</span></span></code></pre>

<p>两个CompletionStage是并行执行的，它们之间并没有先后依赖顺序，other并不会等待先前的CompletableFuture执行完毕后再执行。</p>
<p><strong>其实从功能上来讲,它们的功能更类似thenAcceptBoth，只不过thenAcceptBoth是纯消费，它的函数参数没有返回值，而thenCombine的函数参数fn有返回值。</strong></p>
<pre><code class="highlight java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">return</span> <span class="string">"abc"</span>;
&#125;);
CompletableFuture&lt;String&gt; f =  future.thenCombine(future2, (x,y) -&gt; y + <span class="string">"-"</span> + x);
System.out.println(f.get()); <span class="comment">//abc-100</span></code></pre>

<h2 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h2><p>thenAcceptBoth和runAfterBoth是当两个CompletableFuture都计算完成，而我们下面要了解的方法是当任意一个CompletableFuture计算完成的时候就会执行。</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>
<span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span>
<span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn, Executor executor)</span></span></code></pre>

<p>acceptEither方法是当任意一个CompletionStage完成的时候，action这个消费者就会被执行。这个方法返回CompletableFuture&lt;Void&gt;</p>
<p>applyToEither方法是当任意一个CompletionStage完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture&lt;U&gt;的计算结果。</p>
<p>下面这个例子有时会输出100,有时候会输出200,哪个Future先完成就会根据它的结果计算。</p>
<pre><code class="highlight java">Random rand = <span class="keyword">new</span> Random();
CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">try</span> &#123;
        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));
    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">try</span> &#123;
        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));
    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="keyword">return</span> <span class="number">200</span>;
&#125;);
CompletableFuture&lt;String&gt; f =  future.applyToEither(future2,i -&gt; i.toString());</code></pre>

<h2 id="辅助方法-allOf-和-anyOf"><a href="#辅助方法-allOf-和-anyOf" class="headerlink" title="辅助方法 allOf 和 anyOf"></a>辅助方法 allOf 和 anyOf</h2><p>前面我们已经介绍了几个静态方法：completedFuture、runAsync、supplyAsync,下面介绍的这两个方法用来组合多个CompletableFuture。</p>
<pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></code></pre>

<p>allOf方法是当所有的CompletableFuture都执行完后执行计算。</p>
<p>anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。</p>
<p>下面的代码运行结果有时是100,有时是”abc”。</p>
<blockquote>
<p>但是anyOf和applyToEither不同。anyOf接受任意多的CompletableFuture但是applyToEither只是判断两个CompletableFuture,anyOf返回值的计算结果是参数中其中一个CompletableFuture的计算结果，applyToEither返回值的计算结果却是要经过fn处理的。当然还有静态方法的区别，线程池的选择等。</p>
</blockquote>
<pre><code class="highlight java">Random rand = <span class="keyword">new</span> Random();
CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">try</span> &#123;
        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));
    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="keyword">return</span> <span class="number">100</span>;
&#125;);
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;
    <span class="keyword">try</span> &#123;
        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));
    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="keyword">return</span> <span class="string">"abc"</span>;
&#125;);
<span class="comment">//CompletableFuture&lt;Void&gt; f =  CompletableFuture.allOf(future1,future2);</span>
CompletableFuture&lt;Object&gt; f =  CompletableFuture.anyOf(future1,future2);
System.out.println(f.get());</code></pre>

<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>如果你用过Guava的Future类，你就会知道它的Futures辅助类提供了很多便利方法，用来处理多个Future，而不像Java的CompletableFuture，只提供了allOf、anyOf两个方法。 比如有这样一个需求，将多个CompletableFuture组合成一个CompletableFuture，这个组合后的CompletableFuture的计算结果是个List,它包含前面所有的CompletableFuture的计算结果，guava的Futures.allAsList可以实现这样的功能，但是对于java CompletableFuture，我们需要一些辅助方法：</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; sequence(List&lt;CompletableFuture&lt;T&gt;&gt; futures) &#123;
       CompletableFuture&lt;Void&gt; allDoneFuture = CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()]));
       <span class="keyword">return</span> allDoneFuture.thenApply(v -&gt; futures.stream().map(CompletableFuture::join).collect(Collectors.&lt;T&gt;toList()));
   &#125;
<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CompletableFuture&lt;Stream&lt;T&gt;&gt; sequence(Stream&lt;CompletableFuture&lt;T&gt;&gt; futures) &#123;
       List&lt;CompletableFuture&lt;T&gt;&gt; futureList = futures.filter(f -&gt; f != <span class="keyword">null</span>).collect(Collectors.toList());
       <span class="keyword">return</span> sequence(futureList);
   &#125;</code></pre>

<p>或者Java Future转CompletableFuture:</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">CompletableFuture&lt;T&gt; <span class="title">toCompletable</span><span class="params">(Future&lt;T&gt; future, Executor executor)</span> </span>&#123;
    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;
        <span class="keyword">try</span> &#123;
            <span class="keyword">return</span> future.get();
        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
        &#125;
    &#125;, executor);
&#125;</code></pre>

<p>github有多个项目可以实现Java CompletableFuture与其它Future (如Guava ListenableFuture)之间的转换，如<a href="https://github.com/spotify/futures-extra" target="_blank" rel="noopener">spotify/futures-extra</a>、<a href="https://github.com/lukas-krecan/future-converter" target="_blank" rel="noopener">future-converter</a>、<a href="https://github.com/scala/scala-java8-compat/blob/master/src/main/scala/scala/compat/java8/FutureConverters.scala" target="_blank" rel="noopener">scala/scala-java8-compat</a> 等。</p>

</div>
						</div>
					</article>
				</div>
			</div>
		</div>
		<footer id="footer" class="wrapper">
			<div class="inner">
				<div id="footer-copyright">
					© 2020 <a href="https://github.com/yoloz" rel="external nofollow noreferrer"
						target="_blank">Yoloz</a><br>
					Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/"
						rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>.
				</div>
				<div id="footer-links">
					<a href="https://twitter.com/796c7a" rel="external nofollow noreferrer" class="footer-link"
						target="_blank"><i class="fa fa-twitter"></i></a>
					<a href="https://github.com/yoloz" rel="external nofollow noreferrer" class="footer-link"
						target="_blank"><i class="fa fa-github-alt"></i></a>
				</div>
			</div>
		</footer>
	</div>

	<!-- 引入代码高亮的 js -->
	
<script src="/lib/highlight/highlight.pack.js"></script>


	<!-- 引入 jquery -->
	
<script src="/lib/jquery-3.4.1.min.js"></script>


	<!-- 引入 pjax -->
	
<script src="/lib/jquery.pjax.js"></script>


	<!-- 引入 js 文件 -->
	
<script src="/js/main.js"></script>


	<!-- <script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.0.4/lib/L2Dwidget.min.js"></script>
	<script type="text/javascript">
	L2Dwidget.init();
	</script> -->

</body>

</html>