---
title: du,df
comments: false
toc: false
date: 2020-02-26 18:17:56
categories: linux
tags:
---

## du

disk usage,是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和。

``` sh
du -sh  #查看当前目录总共占的容量，不单独列出各子项占用的容量
du -sh file  #查看文件file的大小
du -ah --max-depth=1  #查看当前目录下一级子文件和子目录占用的磁盘容量
```
> a表示显示目录下所有的文件和文件夹（不含子目录）
> h表示以以K，M，G为单位，提高信息的可读性
> max-depth表示目录的深度。 


* 按照空间大小排序
`du|sort -nr|more`

> sort:
>
>-n, --numeric-sort          compare according to string numerical value
>
>-h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)

## df

disk free，通过文件系统来快速获取空间大小的信息，当我们删除一个文件的时候，这个文件不是马上就在文件系统当中消失了，而是暂时消失了，当所有程序都不用时，才会根据OS的规则释放掉已经删除的文件， df记录的是通过文件系统获取到的文件的大小，他比du强的地方就是能够看到已经删除的文件，而且计算大小的时候，把这一部分的空间也加上了，更精确了。

``` sh
df #显示磁盘使用情况
df -T #列出文件系统的类型
df -h #以更易读的方式显示目前磁盘空间和使用情况
```

**当文件系统也确定删除了该文件后，这时候du与df就一致了**

## 文件系统满的处理

常规的步骤是：确认文件系统使用率、找出大文件（目录）、清理。某些极端情况，即便删除了大文件，也会发现文件系统空间未释放。

### 查看文件系统利用率

      df命令（即disk free的简称），用于报告文件系统的使用量。我们通过`df`命令，先看初步定位一下是否有利用率(Use%)为100%或可用量（Avail）几乎为0的的文件系统。如果存在，则需要注意。如果只看某个文件或目录所在的文件系统，则可以跟上路径名，比如`df /home`只会报告/home所在的文件系统的情况。

### 找出大文件（目录）

    找出满的文件系统，下一步是确定哪些文件最占空间，这样清理起来更有效率。找出大文件可以通过`du`命令完成（disk usage的简称）。du命令默认是递归输出所有子目录的大小，如果子目录很多层，会让人眼花缭乱，并不实用，倒是`du -sh *`更为实用。其中-h 代表用human readable的格式显示空间大小单位，而-s即summarize，即仅输出总大小，所有`du -sh *`代表输出当前目录各子目录或文件的大小。递归的使用`du -sh *`查看，直到找出需要删除的大文件。

### 删除

删除就很容易了，直接rm或使用find命令根据条件rm。

### 删除后空间不释放

上述3个步骤，基本可以处理文件系统满的问题，但某些特殊情况，会出现删除后空间不释放的问题。更诡异的是明明在文件系统根目录使用`du -sh .`查看总使用大小，竟然和`df -h`显示的使用大小不一致。这很可能是出现了某个进程占用了该文件。在这种情况下，即便删除了文件，文件系统也不会释放。具体验证的方法就是使用`lsof | grep "(deleted)"`查看是否存在你删除的文件，并查看其进程ID，根据进程ID找到对应进程，尝试重启该进程。
> 出现这种诡异的现象，是因为Linux下文件系统使用inode进行管理。对进程来说，对文件的引用并不是通过路径名实现，所有的路径名都要转换成一个inode的结点id，路径名只不过是提供给“用户”的概念。 正式基于此，Linux下竟然可以在进程使用的时候，对占用的文件进行重命名甚至删除操作。因为，进程根本不关心路径名！

**总结**
* 使用`df`确定是否存在文件系统满
* 使用`du -sh *`逐级搜索大文件或目录
* 使用`rm -rf`删除
> 如果发现文件删除后，`df`没有明显的看到文件系统释放，使用`lsof | grep "(deleted)"`查看是否存在删除的文件仍然被某个进程使用



